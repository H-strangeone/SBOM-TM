from __future__ import annotations

import json
import re
from dataclasses import asdict, dataclass, field
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional

from packaging.version import InvalidVersion, Version

from .context_loader import ServiceContext

@dataclass(slots=True)
class Rule:
    id: str
    description: str
    conditions: List[Dict[str, Any]]
    result: Dict[str, Any]
    score_factors: Dict[str, float]
    severity: Optional[str] = None
    last_updated: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


class RuleEngine:
    def __init__(self, rules: List[Rule]):
        self.rules = rules

    def to_markdown(self, threats: Iterable[Dict[str, Any]]) -> str:
        """Render a simple markdown report from a list of threat payloads.

        Expects threats to be the same shape produced by the service threat
        export: each entry should contain at least `score`, `rule_id` and
        `evidence` with `cve`, `severity` and optional `intel` metadata.
        """
        from datetime import datetime

        tlist = list(threats or [])
        total = len(tlist)
        now = datetime.utcnow().isoformat() + "Z"

        lines: List[str] = []
        lines.append(f"# SBOM-TM Security Report")
        lines.append("")
        lines.append(f"_Generated: {now}_")
        lines.append("")
        lines.append(f"**Total threats:** {total}")
        lines.append("")

        if total == 0:
            lines.append("No threats detected by the rule engine.")
            return "\n".join(lines)

        # summary by severity
        counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for t in tlist:
            sev = None
            ev = t.get("evidence") or {}
            sev = ev.get("severity") or t.get("rule_severity") or t.get("severity")
            if isinstance(sev, str):
                key = sev.lower()
                if key in counts:
                    counts[key] += 1

        lines.append("**Severity breakdown:**")
        lines.append("")
        lines.append(f"- Critical: {counts['critical']}")
        lines.append(f"- High: {counts['high']}")
        lines.append(f"- Medium: {counts['medium']}")
        lines.append(f"- Low: {counts['low']}")
        lines.append("")

        # table header
        lines.append("| Score | Rule | CVE | Component | Severity | KEV | Recommendations |")
        lines.append("|---:|---|---|---|---|---|---|")

        for t in tlist:
            score = t.get("score")
            rule = t.get("rule_id") or t.get("rule") or "-"
            evidence = t.get("evidence") or {}
            cve = evidence.get("cve") or "-"
            sev = evidence.get("severity") or t.get("rule_severity") or "-"
            comp = "-"
            try:
                comp = (t.get("target") or {}).get("component") or "-"
                if isinstance(comp, dict):
                    comp = comp.get("name") or comp.get("purl") or str(comp)
            except Exception:
                comp = "-"

            intel = evidence.get("intel") or {}
            kev = (
                "âœ…" if intel.get("kev_listed") or intel.get("kev") or intel.get("cisa") else ""
            )
            intel_sources = ", ".join([str(s) for s in (intel.get("sources") or [])]) if intel.get("sources") else ""
            chatter = intel.get("chatter_score")
            intel_note = ""
            if intel_sources or chatter:
                parts = []
                if intel_sources:
                    parts.append(f"sources: {intel_sources}")
                if chatter is not None:
                    try:
                        parts.append(f"chatter: {float(chatter):.2f}")
                    except Exception:
                        parts.append(f"chatter: {chatter}")
                intel_note = "; ".join(parts)

            # create CVE link when possible
            cve_md = cve
            if isinstance(cve, str) and cve.upper().startswith("CVE-"):
                cve_md = f"[{cve}](https://nvd.nist.gov/vuln/detail/{cve})"

            # recommendations
            recs = t.get("recommended_actions") or t.get("recommendations") or []
            if isinstance(recs, (list, tuple)):
                rec_text = "<br>".join([str(r) if isinstance(r, str) else r.get("detail", str(r)) for r in recs])
            else:
                rec_text = str(recs)

            # include intel summary in recommendations column if present
            if intel_note:
                rec_text = f"{rec_text}<br>**Intel:** {intel_note}"

            lines.append(f"| {score} | {rule} | {cve_md} | {comp} | {sev} | {kev} | {rec_text} |")

        lines.append("")
        lines.append("---")
        lines.append("")
        lines.append("Generated by SBOM-TM")

        return "\n".join(lines)

    @classmethod
    def from_directory(cls, directory: Path) -> "RuleEngine":
        rules: List[Rule] = []
        for path in sorted(directory.glob("*.json")):
            try:
                with path.open("r", encoding="utf-8") as fh:
                    payload = json.load(fh)
                if isinstance(payload, dict):
                    payload = [payload]
                for entry in payload:
                    rule = _build_rule_from_entry(entry)
                    if rule is not None:
                        rules.append(rule)
            except (OSError, json.JSONDecodeError) as exc:
                print(f" Error loading {path.name}: {exc}")
        return cls(rules)

    def evaluate(
        self,
        component: Dict[str, Any],
        vulnerability: Dict[str, Any],
        service: Optional[ServiceContext],
        threatintel: Optional[Dict[str, Any]] = None,
    ) -> Iterable[Dict[str, Any]]:
        context = {
            "component": component,
            "vuln": vulnerability,
            "context": asdict(service) if service else {},
            "threatintel": threatintel or {},
        }

        for rule in self.rules:
            if all(_condition_matches(condition, context) for condition in rule.conditions):
                yield {
                    "rule_id": rule.id,
                    "description": rule.description,
                    "pattern": rule.result.get("pattern", []),
                    "objective": rule.result.get("objective", []),
                    "recommendations": rule.result.get("recommendations", []),
                    "pattern_multiplier": rule.result.get("pattern_multiplier", 1.0),
                    "score_factors": rule.score_factors,
                    "rule_severity": rule.severity,
                    "rule_metadata": rule.metadata,
                    "last_updated": rule.last_updated,
                }


def _condition_matches(condition: Dict[str, Any], context: Dict[str, Any]) -> bool:
    if not condition:
        return True
    if "match_type" in condition:
        return _evaluate_complex_condition(condition, context)
    field, value = next(iter(condition.items()))
    actual = _dig_value(context, field)
    if isinstance(value, dict):
        for operator, expected in value.items():
            if not _compare(operator, actual, expected):
                return False
        return True
    return actual == value


def _dig_value(payload: Dict[str, Any], field: str) -> Any:
    if field.startswith("vulnerability."):
        field = "vuln." + field.split(".", 1)[1]
    elif field.startswith("package."):
        field = "component." + field.split(".", 1)[1]
    current: Any = payload
    for token in field.split("."):
        if isinstance(current, dict):
            current = current.get(token)
        else:
            return None
    return current


def _compare(operator: str, actual: Any, expected: Any) -> bool:
    if operator == "eq":
        return actual == expected
    if operator == "neq":
        return actual != expected
    if operator == "gte":
        return actual is not None and actual >= expected
    if operator == "lte":
        return actual is not None and actual <= expected
    if operator == "gt":
        return actual is not None and actual > expected
    if operator == "lt":
        return actual is not None and actual < expected
    if operator == "in":
        return actual in expected if isinstance(expected, (list, set, tuple)) else False
    if operator == "contains":
        if isinstance(actual, (list, set, tuple)):
            return expected in actual
        if isinstance(actual, str):
            return str(expected) in actual
        return False
    if operator == "exists":
        return actual is not None
    return False


def _evaluate_complex_condition(condition: Dict[str, Any], context: Dict[str, Any]) -> bool:
    match_type = str(condition.get("match_type", "")).lower()

    if match_type in {"regex", "regex_any"}:
        pattern = condition.get("pattern")
        if not pattern:
            return False
        flags_value = condition.get("flags", "")
        regex_flags = 0
        if isinstance(flags_value, str) and "i" in flags_value.lower():
            regex_flags |= re.IGNORECASE
        field_list = condition.get("fields") if match_type == "regex_any" else [condition.get("field")]
        if not field_list:
            return False
        for field in field_list:
            if not field:
                continue
            actual = _dig_value(context, str(field))
            if actual is not None and re.search(str(pattern), str(actual), regex_flags):
                return True
        return False

    if match_type in {"any_of", "in_list"}:
        field = condition.get("field")
        values = condition.get("values", [])
        if not field:
            return False
        actual = _dig_value(context, str(field))
        if actual is None:
            return False
        normalized_values = {str(value) for value in values}
        return str(actual) in normalized_values

    if match_type == "version_lt_field":
        field = condition.get("field")
        compare_to = condition.get("compare_to")
        if not field or not compare_to:
            return False
        left = _dig_value(context, str(field))
        right = _dig_value(context, str(compare_to))
        if left is None or right is None:
            return False
        try:
            return Version(str(left)) < Version(str(right))
        except InvalidVersion:
            return False

    if match_type == "missing_fields":
        fields = condition.get("fields", [])
        for field in fields:
            value = _dig_value(context, str(field))
            if value in (None, "", [], {}):
                return True
        return False

    if match_type == "and":
        subconditions = condition.get("subconditions", [])
        return all(_condition_matches(subcondition, context) for subcondition in subconditions)

    if match_type == "exists":
        field = condition.get("field")
        if not field:
            return False
        return _dig_value(context, str(field)) not in (None, "")

    if match_type == "not_exists":
        field = condition.get("field")
        if not field:
            return False
        return _dig_value(context, str(field)) in (None, "")

    return False


def _build_rule_from_entry(entry: Dict[str, Any]) -> Optional[Rule]:
    rule_id = entry.get("id") or entry.get("rule_id")
    if not rule_id:
        return None

    if entry.get("enabled") is False:
        return None

    title = entry.get("title")
    description = entry.get("description")
    if title and description:
        rule_description = f"{title}: {description}"
    else:
        rule_description = title or description or ""

    raw_conditions = entry.get("conditions")
    if not raw_conditions and entry.get("condition"):
        raw_conditions = [entry["condition"]]
    if not raw_conditions:
        return None

    result = entry.get("result") or {}
    if not result:
        tags = entry.get("tags") or []
        remediation = entry.get("remediation")
        recommendations: List[Dict[str, Any]] = []
        if remediation:
            recommendations.append({"type": "remediation", "detail": remediation})
        result = {
            "pattern": tags or [rule_id],
            "objective": entry.get("objective", []),
            "recommendations": recommendations,
            "pattern_multiplier": entry.get("pattern_multiplier", 1.0),
        }

    return Rule(
        id=str(rule_id),
        description=rule_description,
        conditions=list(raw_conditions),
        result=result,
        score_factors=entry.get("score_factors", {}),
        severity=entry.get("severity"),
        last_updated=entry.get("last_updated"),
        metadata={
            "scope": entry.get("scope"),
            "tags": entry.get("tags"),
            "remediation": entry.get("remediation"),
        },
    )
